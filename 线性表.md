# 线性表
## 定义内容
定义：具有相同数据类型的n个数据元素的序列。  
基本操作：  
初始化：`InitList(&L)`  
求表长：`Length(L)`  
按值查找：`LocateElem(L,e)`  
按位查找：`GetElem(L,i)`  
插入：`ListInsert(&L,i,e)`  
删除：`ListDelete(&L,i,&e)`  
## 顺序表
线性表的顺序存储就叫顺序表，是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑相邻的元素其存储位置也相邻。  
顺序表一般用数组表示，元素$a_i$的位序为i，其在数组中的下标为i-1。


###  顺序表的存储结构
根据分配内存的方式可以把顺序表分为静态分配与动态分配。静态分配的内存一次性分配好，但是容易溢出；动态分配的内存根据实际需要动态地分配。  

存储结构不仅包括存储的顺序表的首地址，还包括其长度等信息。
#### 静态分配顺序表
```c
#define MAXSIZE 50
typedef struct{
    ElemType data[MAXSIZE]; //分配连续存储空间，将首地址返回给常量指针data
    int length; //表长度
}SqList;
```
#### 动态分配顺序表
```c
#define INITSIZE 100
typedef struct{
    ElemType *data; //首地址
    int maxsize, length; //最大长度，表长度
}SeqList;

//初始化方式
L.data = (ElemType *)malloc(sizeof(ElemType) * INITSIZE)
```
### 顺序表的基本操作
#### 初始化
初始化的任务在是创建了上述的存储结构之后，第一时间把长度等信息初始化。
```c
//静态顺序表的初始化
SqList L;//创建顺序表，声明中已经创建了存储空间

void InitList(SqList &L){
    L.length = 0;
}
```
```c
//动态分配顺序表的初始化
SeqList L;// 创建顺序表

void InitList(SqList &L){
    L.data = (ElemType *)malloc(sizeof(ElemType) * INITSIZE);
    L.maxsize = INITSIZE;
    L.length = 0;
}
```
#### 插入
插入函数`ListInsert(&L,i,e)`中的 $i$ 的定义是元素被插入后的位序。  
插入函数的结果是：若 i 的输入不合法，则返回flase；否则，将第 i 个元素及其之后的所有元素往后移动一个位置，然后将元素插入第 i 个位置中。最后顺序表的长度增加 1 ，插入成功，返回true。

时间复杂度：$O(n)$
```c
//顺序表插入
bool ListInsert(SqList &L, int i, ElemType e){
    if(i < 1 || i > L.length + 1) return false;
    if(L.length >= MAXSIZE) return false;
    for(int j = L.length; j >= i; j--) L.data[j] = L.data[j - 1];// j为要移动的元素的位序
    L.date[i - 1] = e;
    L.length++;
    return true;
}
```
#### 删除
删除函数`ListDelete(&L,i,&e)`中的 $i$ 的定义是被删除元素的位序。  
删除函数的结果是：若 i 的输入不合法，则返回flase；否则，将第 i 个元素赋值给引用变量 e ，然后将第 i+1 个元素及其之后的所有元素依次往前移动一个位置，返回true。  
时间复杂度：$O(n)$
```c
bool ListDelete(SqList &L, int i, ElemType &e){
    if(i < 1 || i > L.length) return false;
    e = L.data[i - 1];
    for(int j = i; j < L.length; j++) L.data[j-1]=L.data[j];// j为要移动的元素的下标。
    L.length--;
    return true;
}
```
#### 按值查找
作用：查找第一个元素值等于 e 的元素，并返回位序。  
时间复杂度：$O(n)$
```c
int LocateElem(SqList L, Elemtype e){
    int i;
    for(i = 0; i < L.length; i++){
        if(L.data[i] == e) 
            return i + 1;// 返回位序
    }
    return 0;// 0表示没找到
}
```

## 单链表
线性表的链式存储也叫做单链表。链表的结点除了存放当前元素 data，还存放指向后继的指针 next。  
链表中各个元素的存储位置是散乱分布在存储空间中的，要访问某一个元素，只能依次从第一个结点到第二个第三个最后找到。
### 结点与单链表的表示
```c
typedef struct{
    ElemType data;
    struct LNode *next;// 必须加上struct
}LNode, *LinkList;// LinkList是头指针，也代表一个链表。
```
不带头结点的单链表：头指针指向第一个数据结点。  
带头节点的单链表（默认情况）：头指针指向头结点，头节点指向第一个数据结点。引入头结点，在处理第一个元素和空表的时候，头指针都不变，只变头结点。
### 单链表的基本操作

#### 链表的基本语法
```c
// 设 p 是指向某一个结点的指针
//访问当前结点的数据域的方式（只能有下面的方式）
p->data 或者 (*p).data
// 指向下一个结点的指针
p->next 或 (*p).next
//访问下一个结点的数据域
p->next->data 或者 (*(*p).next).data
```
#### 单链表的初始化
初始化就是创建头结点，让头指针指向头结点，头结点指向NULL。
```c
LinkList L;// 创建头指针

bool InitList(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));// 创建头结点
    L->next = NULL;
    return true;
}
```
#### 单链表求表长度
单链表的求长度和查找都可以看作一个人在贯通的室内走廊里面行走，依次查看房屋。  
表长度即链表中数据结点的个数，需要设一个计数器，从第一个结点开始依次访问所有结点，每次计数器 + 1。  
时间复杂度$O(n)$
```c
    int length(LinkList L){
        int len = 0;
        LinkList p = L;// 初始指针当前访问的结点，开始是头结点。
        while(p->next != NULL){// 先用指针试探，有结点才使len增加
            len++;
            p = p->next;
        }
        return len;
    }
```
#### 按序号查找
查找第 i 个数据元素，并返回其 *指针*。若超出表长，则返回NULL。  
时间复杂度:$O(n)$
```c
LinkList GetElem(LinkList L, int i){
    //算法可查找的序号范围是0到n。
    int cnt = 0; //记录当前访问的数据元素位序
    LinkList p = L; //记录当前指针，初始为头结点，指针和计数器同步
    while(p != NULL && cnt < i){
        cnt++;
        p = p->next;
    }
    return p;
}
```
#### 按值查找
按值查找第一个与值相同的数据元素，若成功，返回指针，若没有，返回NULL。
```c
LinkList LocateElem(LinkList L, ElemType e){
    //相比于按序查找，只需要把条件判定条件改一下即可
    LinkList p = L->next;
    while(p != NULL && p->data != e){
        p = p->next;
    }
    return p;
}
```
#### 插入结点
将元素 e 插入链表的第 i 个位置。首先找到指向第 i-1 个结点的指针，若没有找到则返回false，若找到了，则先创建新结点，然后让新结点指向第 i 个结点，再让第 i-1 个结点指向新结点。
```c
bool ListInsert(LinkList &L, int i, ElemType e){
    //找到指向第 i-1个结点的指针（按序查找），由于插入的位序是1到n+1，因此i-1的正常范围是0到n，可以直接用上述按序查找算法。
    LinkList p = L;
    int cnt = 0;
    while(p != NULL && cnt < i - 1){
        cnt++;
        p = p->next;
    }
    if(p == NULL || cnt > i-1 )
        return false;
    //创建新结点s
    s = (LinkList)malloc(sizeof(LNode));
    s->data = e;
    //让新结点s指向原第 i 个结点
    s->next = p->next;
    //让原第i-1个结点指向新结点
    p->next = s;
    return true;
}
```
#### 删去结点
删去第 i 个结点。先找到指向第 i-1 个结点的指针，将其后继改为第 i+1 个结点。然后将删去的结点赋值给引用变量e，最后释放第 i 个结点的动态分配的存储空间。
```c
bool ListDelete(LinkList &L, int i, ElemType &e){
    //找到指向第 i-1 个结点的指针，由于删除数据的位序是1到n，因此i-1的正常范围是0到n-1，而不是之前0到n。因此查找算法中把截止条件改为到第n-1个结点为止。
    int cnt = 0;
    LinkList p = L;
    while(P->next != NULL && cnt < i - 1){//到第n个结点为止。
        cnt++;
        p = p->next;
    }
    if(p->next == NULL || cnt > i - 1)// i为n或i<0都不可以
        return false;
    //将第 i-1 个结点的后继改为第 i+1 个结点
    LinkList q = p->next;
    p->next = q->next;
    //赋值，释放
    e = q->data;
    free(q);
    return true;
}
```
#### 采用头插法建立单链表
头插法。创建新结点，新结点指向第1个结点，头结点指向新结点。  
读入数据的顺序与在链表中的顺序相反
```c
LinkList List_HeadInsert(LinkList &L){
    //创建头结点
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    //循环建立链表
    int x;
    LinkList s;
    scanf("%d", &x);
    while(x != 9999){//x=9999表示结束输入
    s = (LinkList)malloc(sizeof(LNode));
    s->data = x;
    s->next = L->next;
    L->next = s;
    scanf("%d", &x);    
    }
    return L;
}
```
#### 采用尾插法建立单链表
尾插法：创建新结点，最后一个结点指向新结点，然后更改尾指针指向新结点。  
读入数据的顺序与在链表中的顺序相同。  
```c
LinkList List_TailInsert(LinkList &L){
    //创建头结点和尾指针
    L = (LinkList)malloc(sizeof(LNode));
    LinkList r = L;//尾指针，指向最后一个结点。

    int x;
    LinkList s;
    scanf("%d", &x);
    while(x != 9999){
        s = (LinkList)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d",&x);
    }
    r->next = NULL;
    return L;
}
```
## 双链表
双链表的结点中有两个指针prior和next
### 双链表结点表示
```c
typedef struct{
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinkList;
```
### 基本操作
双链表的按序查找和按值查找与单链表相同，都是从头结点开始查找。  
但是插入和删除中，需要额外对prior指针进行修改。
#### 插入
将数据元素插入第 i 个结点位置，需要先找到指向第 i-1 个结点的指针，然后创建新结点，让新结点向前指向第 i 个结点，第 i 个结点向后指向新结点，然后让第 i-1 个结点向前指向新结点，新结点向后指向第 i-1 个结点。
```c
bool ListInsert(DLinkList &L, int i, ElemType){
    //查找指向第 i-1 个结点的指针
    int cnt = 0;
    DLinkList p = L;
    while(p != NULL && cnt < i - 1){
        cnt++;
        p = p->next;
    }
    if(p == NULL || cnt > i - 1)
        return false;
    //创建新结点
    DLinkList s;
    s = (DLinkList)malloc(sizeof(DNode));
    s->data = e;
    //插入(不同之处)(先处理没有直接指针指向的第 i 个结点)
    s->next = p->next;
    p->next->prior = s;
    p->next = s;
    s->prior = p;
    
    return true;
}
```
#### 删除
将第 i 个数据元素删除，需要先找到指向第 i-1 个结点的指针，把第 i 个结点的数据赋值给引用变量 e，然后让第 i-1 个结点向前指向第 i+1 个结点，第 i+1 个结点向后指向第 i-1 个结点，最后释放第 i 个结点。
```c
bool ListDelete(DLinkList &L, int i, ElemType &e){
    //找到指向第 i-1 个结点的指针
    int cnt = 0;
    DLinkList p = L;
    while(p->next != NULL && cnt < i-1){
        cnt++;
        p = p->next;
    }
    if(p->next == NULL || cnt > i-1)
        return false;
    //删除操作，借助指向被删结点的指针q
    DLinkList q = p->next;
    e = q->data;
    p->next = q->next;
    q->next->prior = p;
    free(q);

    return true;
}
```
## 循环链表
### 循环单链表
表中最后一个结点的指针不是NULL，而是指向头结点，从而形成一个环。  
循环单链表为空的条件是头结点指向自己。  
循环单链表最好设置*尾指针*，这样无论在表头还是表尾插入/删除时间复杂度都为$O(1)$
### 循环双链表
表中头结点的prior指针指向最后一个结点，最后一个结点的next指向头指针。
## 静态链表
用数组来实现链表。预先分配一块连续的内存空间，每一个结点仍然包括数据域与指针域，只不过指针的内容是结点在数组中的下标。数组的第0位为头结点。结束标志为 next = -1。
### 静态链表的结点与结构
```c
#define MAXSIZE 50
typedef struct{
    ElemType data;
    int next;
}SLinkList[MAXSIZE];
```