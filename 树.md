# 树与二叉树
### 定义
树是n个结点的集合，其递归定义为：  
1. 没有结点的树为空树
2. 有n个结点的非空树
   - 有且只有1个根结点
   - 当n>1，除了根结点外的其他结点可分为有限个互不相交的子树  

树也可以按其层次结构直接定义：  
1. 根结点没有前驱，除此之外每一个结点有且仅有1个前驱
2. 树中所有结点都可以有零或任意多个后继
   
结点的高度是其子树的层数。树的 *高度/深度* 是树中结点的最大层数

结点的 *度* 就是结点的孩子数，树的度是其结点的最大度数。度大于0的称为分支结点，度等于零的称为叶结点 。

树中两结点的路径是从上到下的一条一条边。

森林：互不相交的树的集合，等价于没有根结点。
### 基本性质
1. 树的结点数n等于所有结点的度数之和+1。(度数之和为边之和)
2. 度为m的树中第i层上至多有$m^{i-1}$个结点，$i\ge 1$。
3. 高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点
4. 度为m，具有n个结点的树的最小高度h为$h_{\text{min}}=[\log_m(n(m-1)+1)]+1$
5. 度为m，具有n个结点的树的最大高度h为$h=n-m+1$
6. 总的度数，既可以从上到下看每一个结点的孩子数，也可以从下到上看到每一个孩子都有唯一的一个父亲。

# 二叉树
## 定义
树是n个结点的集合，其递归定义为：    
1. 没有结点的二叉树为空树
2. 有n个结点的非空二叉树
   - 有且只有1个根结点
   - 当n>1，除了根结点外的其他结点可分为1个左子二叉树和右子二叉树

注意：  
1. 二叉树是有序树，即使结点只有一个子树，也要区分是左子树还是右子树
2. 二叉树不等于度为2的有序树。二叉树的度和序号是固有性质，而度为2的有序树是在没有固有特殊性质的树的基础上的一种特例实现。

分类： 
1. 满二叉树。其形式和结点的序号完全确定
2. 完全二叉树。完全二叉树的结点序号与同高度的满二叉树一致。因此，高度为h的完全二叉树的前h-1层都是满的，第h层从左到右都依次排开，但不一定排满。
3. 二叉排序树。（归纳定义）左子树上的所有结点的关键字都小于根结点的关键字，右子树上的所有结点的关键字都大于根结点的关键字，且左子树和右子树仍然是二叉排序树。
4. 平衡二叉树。树中任意一个结点的左子树和右子树的高度之叉的绝对值不超过1
5. 正则二叉树。树中每个分支结点都有两个孩子，即树中只要度为0或2的结点。
## 基本特性
1. 非空二叉树上的叶结点数等于度为2的结点数+1，即$n_0=n_2+1$（度为1的结点的作用只是垂直向下延伸到叶结点，因此计算叶结点数时可以直接不要，用归纳法即可得。或者用边与结点的关系。）
2. 第k层最多有$2^{k}-1$个结点
3. 结点数为n的完全二叉树的特点（根本上还是边和结点的关系）
   * 最后一个分支结点的编号为$i=[\frac{n}{2}]$，最后一个分支结点之前全是度为2的分支结点，之后全是叶结点，它本身可能是度1或度2的分支结点。（$2i-1\le n-1 \le 2i$）。$i$也是最后一个结点的双亲结点的编号。
   * 推论：度为1的分支结点只能是最后一个分支结点，最多只有一个，且其只有左孩子。
   * 推论：度为1的分支结点或叶结点之后的全部结点都是叶结点
   * 推论：若编号为$i$的结点有左右孩子，则左孩子编号为$2i$，右孩子的编号为$2i+1$
   * 高度$h=[\log_2(n+1)]+1=[\log_2n]+1$
##  二叉树的存储
### 顺序存储
对于完全二叉树，其形式完全确定，因此结点的编号与其在二叉树的位置一一对应，因此只需要按照其编号的顺序依次存储结点的值即可。  
对于一般的二叉树，可以把它看作完全二叉树的一部分，按照在完全二叉树上的编号来依次顺序存储各个结点的值。
### 链式存储
二叉链表的结点至少包括3个域：数据域data，左指针域lchild，右指针域rchild。
```c
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild;
    struct BiTNode *rchild;
}BiTNode, *BiTree;
```
在含有n个结点的二叉链表中，含有n+1个空链域。
## 二叉树的遍历与线索二叉树
### 二叉树的遍历
二叉树的遍历就是按照线性顺序一个一个访问二叉树的结点。按照遍历的方式，可以分为先序遍历，中序遍历，后序遍历，以及层次遍历。其中前三种遍历都是递归定义的，按照访问根结点的顺序分类，并都固定先访问左子树，再访问右子树，即分别为NLR,LNR,LRN。  
用分块（递归）与最小的三元树去理解！
- 先序：上先下后，左先右后
- 中序：左先右后
- 后序：下先上后，左先右后
#### 先序遍历
先访问根结点，再先序遍历左子树，再先序遍历右子树（归根结底只会访问根结点）
```c
   void preOrder(BiTree T){
      // 先序遍历
      // T是指向结点的指针
      if(T! = NULL){
         visit(T);
         preOrder(T -> lchild);
         preOrder(T -> rchild);
      }
   }
```
#### 中序遍历
```c
   void InOrder(BiTree T){
      // 中序遍历
      // T是指向结点的指针
      if(T! = NULL){
         InOrder(T -> lchild);
         visit(T);
         InOrder(T -> rchild);
      }
   }
```
#### 后序遍历
```c
   void PostOrder(BiTree T){
      // 后序遍历
      // T是指向结点的指针
      if(T! = NULL){
         PostOrder(T -> lchild);
         PostOrder(T -> rchild);
         visit(T);
      }
   }
```
#### 层次遍历(非常熟练)
自上而下，从左到右的层次遍历。需要借助队列：
1. 根结点入队
2. 若队非空，则队头出队，如果有左孩子，左孩子入队，如果有右孩子，右孩子入队
3. 重复2，直到队列为空
```c
void levelOrder(BiTree T){
   initQueue(Q);
   BiTree p;
   enQueue(Q,T);
   while(!isEmpty(Q)){
      deQueue(Q,p);
      visit(p);
      if(p->lchild != NULL) enQueue(Q, p->lchild);
      if(p->rchild != NULL) enQueue(Q, p->rchild);
   }
}
```
#### 由遍历序列确定二叉树
给定中序序列，和前序，后序，遍历序列的其中一个，就可以唯一（如果存在）确定二叉树。因为中序序列是左子树+根+右子树，而其余的给出根，因此可以把中序序列的三个成分分开，并且由其他的序列给出左右子树的根，这样一直进行，就可以把二叉树唯一确定。
- 中序+前序。中序序列是左子树+根+右子树，而前序序列第一个为根，因此可以把中序序列的三个成分分开，并且把前序序列分成根+左子树+右子树。这样问题就变成左子树和右子树的确定，可以重复上述步骤
- 中序+后序。类似
- 中序+遍历。中序序列是左子树+根+右子树，而遍历序列第一个为根，因此可以把中序序列的三个成分分开。而如果左右子树存在，则遍历序列的第三个和第四个就是左右子树的根，因此可以继续把左右子树确定，不断重复。
### 线索二叉树
线索二叉树是利用二叉链表的空指针来存储某一种遍历的前驱与后继，从而将二叉树的结点排成线性序列，方便地进行遍历，二建立检索二叉树的过程就是遍历的过程。加入线索的二叉树为线索二叉树。  
#### 规定：
- 若结点无左子树，则令lchild指向其前驱，并令标识指针ltag为1；否则lchild指向左孩子，标识指针ltag为0。（因为任何排序都是右边在左边的后面）
- 若结点无右子树，则令rchild指向其后继，并令标识指针rtag为1；否则rchild指向右孩子，标识指针rtag为0。
#### 存储结构
```c
typedef struct ThreadNode{
   ElemType data;// 数据域
   struct ThreadNode *lchild, *rchild;// 左右孩子指针 或 线索
   int ltag, rtag;// 标识域
}ThreadNode, *ThreadTree;// 线索链表
```
#### 中序线索二叉树的构造(关键是遍历)
需求：已经建立了一个二叉树，需要将二叉树按照中序顺序建立线索二叉树  
算法思想：首先需要中序遍历二叉树，即让指针p依次指向中序遍历的结点，让pre指向p的前驱，这样每一个结点都有机会指向其前驱或后继承，遍历一次就把所有可以确定的线索全部确定了。
- 如果p为空，什么也不做。
- 如果p非空且没有左孩子，则令p->lchild = pre, ltag = 1
- 如果没有右孩子，则令pre->rchild = p, ltag = 1;
```c
void inThread(ThreadTree &p, ThreadTree &pre){// pre是刚刚访问的结点指针，p是正在访问的结点指针
   //中序线索二叉树的构造函数（用递归方式）
   if(p != NULL){
      inThread(p->lchild, pre);// pre仍然是p->child的前驱！！！
      /*
                     1
                    / \
                   1   1  
                  / \    
                 4   5 
                    / \
                   1   1
                      / \
                     1   1
               */
      // 这由中序遍历的特点决定，因为左子树的前驱就是左下角结点的前驱，它应该等于树的前驱，这样才连得上。
      if(p->lchild == NULL){
         p->lchild = pre;
         p->ltag = 1;
      }
      if(pre != NULL && pre->rchild == NULL){
         pre->rchild = p;
         pre->rtag = 1;
      }
      pre = p;// 容易理解，使得pre保持是前驱。
      inThread(p->rchild, pre);
   }// 结束时pre指向最后一个结点。
}

void creatInThread(ThreadTree T){
   //建立主算法
   ThreadTree pre = NULL;
   if(T != NULL){
      inThread(T, pre);
      pre->rchild = NULL;
      pre->rtag = 1;
   }
}
```
建立了线索二叉树后，可以加上头结点head,使得  
```head->lchild = first ```，  
```head->rchild = last ```，  
```first->lchild = head ```，  
```last->rchild = head ```.
#### 利用中序线索二叉树的遍历
由于肯定不是每一个结点都有后继，所以不能单纯用线索像单链表一样去遍历，但无论如何，线索二叉树已经建立了，有其他办法
1. 若p->rtag == 1，则访问p->rchild
2. 若p->rtag == 0，说明该结点有右孩子，则后继为右子树的左下角。
```c
ThreadNode *firstNode(ThreadTree *p){
   // 从根结点出发，求线索二叉树的第一个结点，一直访问左孩子即可。
   while(p->ltag == 0){// 有左孩子
      p = p->lchild;
   }
   return p;
}
ThreadNode *nextNode(ThreadTree *p){
   // 求结点后继
   if(p->rtag == 1)
      p = p->rchild;
   else return firstNode(p->rchild);
}
void inOrder(ThreadTree *T){
   //遍历算法
   for(ThreadTree *p = firtNode(T); p != NULL; p = nextNode(p))
      visit(p);
}
```
#### 先序线索二叉树的构造与遍历
##### 构造
```c
void preThread(ThreadTree &p, ThreadTree &pre){
   //先序线索二叉树的构造函数
   if(p != NULL){
      if(p->lchild == NULL){
         p->lchild = pre;
         p->ltag = 1;
      }
      if(pre != NULL && pre->rchild == NULL){
         pre->rchild = p;
         pre->rtag = 1;
      }
      pre = p;
      if(p->ltag == 0)
         preThread(p->lchild, pre);
      if(p->rtag == 0)
         preThread(p->rchild, pre);
   }
}
void creatPreThread(ThreadTree T){
   //建立主算法
   ThreadTree *p = NULL;
   if(T != NULL){
      preThread(T,p);
      pre->rchild = NULL;
      pre->rtag = 1;
   }
}
```
##### 遍历
```c
ThreadNode *nextNode(ThreadTree *p){
   // 求结点后继
   if(p->rtag == 1)
      return p->rchild;
   else if(p->lchild != NULL)
      return p->lchild;
   else p->rchild;

}
void preOrder(ThreadTree *T){
   //遍历算法
   for(ThreadTree *p = T; p != NULL; p = nextNode(p))
      visit(p);
}
```
#### 后序线索二叉树的构造与遍历
##### 构造
```c
void postThread(ThreadTree &p, ThreadTree &pre){
   //后序线索二叉树的构造函数
   if(P != NULL){
   postOrder(p->lchild, pre);
   postOrder(p->rchild, pre);
   if(p->lchild == NULL){
         p->lchild = pre;
         p->ltag = 1;
      }
   if(pre != NULL && pre->rchild == NULL){
         pre->rchild = p;
         pre->rtag = 1;
      }
   pre = p;
   }
}
void creatPostThread(ThreadTree T){
   //建立主算法
   ThreadTree *p = NULL;
   if(T != NULL){
      postThread(T,p);
   }
}
```
##### 遍历
```c
ThreadNode *firstNode(ThreadTree *p){
   // 从根结点出发，求后序线索二叉树的第一个结点，一直访问左孩子即可。
   while(p->ltag == 0){// 有左孩子
      p = p->lchild;
   }
   return p;
}
ThreadNode *nextNode(ThreadTree *p){
   // 求结点后继，需要知道双亲，即用三叉链表构建
}
void postOrder(ThreadTree *T){
   //遍历算法
   for(ThreadTree *p = T; p != NULL; p = nextNode(p))
      visit(p);
}
```
# 树与森林（非二叉树）
## 树的存储结构
不管哪一种存储结构，都基于层次遍历的顺序来编号，通过在存储中加入双亲，孩子，兄弟等信息知道如何分层，就完全确定树的结构。
### 1 双亲表示法
用连续的空间来存储，每一个结点增设一个伪指针，其值为其双亲在数组中的位置，根结点在数组初始位置，下标为0，且其伪指针域为-1.（按照层次遍历的顺序排列）
```c
#define MAX_TREE_SIZE 100
typedef struct{
   ElemType data;
   int parent;
}PTNode;
typedef struct{
   PTNode nodes[MAX_TREE_SIZE];
   int n;//结点数
}PTree;
```
双亲表示法可以很快得到双亲结点，但求结点的孩子需要遍历。
### 2 孩子表示法
将每个结点的孩子结点视为线性表，用单链表来存储，因此对于有n个结点的树，总共有n个单链表（包括空表），所有头指针又组成线性表，用顺序存储结构。
### 3 孩子兄弟表示法
也称**二叉树表示法**，即用二叉链表作为存储结构，二叉链表的结点包括：结点值，指向第一个孩子结点的指针，指向下一个兄弟的指针。
```c
typedef struct CSNode{
   ElemType data;
   struct CSNode *firstchild, *nextbrother;
}CSNode, *CSTree;
```
可以方便地实现树转换为二叉树，容易查找孩子和兄弟，但是查找双亲比较麻烦，可再增设一个parent指针域，则查找父结点也很方便。
## 树、森林与二叉树的转换
本质上是对指针的解释不同：
1. 本来就是二叉树，则左右指针分别指向左右孩子，水平向右为兄弟
2. 树或森林转换的二叉树，左右指针分别指第一个孩子和第一个兄弟
### 树转换为二叉树（二叉树表示法）
规则：
1. 每一个结点的左指针指向第一个孩子（左孩子）
2. 每一个结点的右指针指向第一个兄弟（右兄弟）

由于根结点没有兄弟，因此树转换得到的二叉树没有右子树。  
这种方法几何上是把三角形的左边固定，上边变成下边，然后再旋转，就实现了二叉！
### 森林转化为二叉树
先将森林的每一颗树转化为二叉树，再将各个树的根视为兄弟关系，连起来，再以第一棵树的根为轴心旋转45度。
### 二叉树转化为森林（二叉树理解为森林转化成的，左孩子右兄弟）
1. 二叉树的根与左子树为一棵树，右子树为森林转换的二叉树再继续进行分割。
2. 二叉树转换成树（树转换成二叉树的逆变换，转45度，换三角形的边）
## 树和森林的遍历
### 树的遍历
#### 先根遍历
1. 访问根结点
2. 依次先根遍历结点的每颗子树
顺序与这颗树对应的二叉树的先序序列相同（归纳或分块来理解）
#### 后根遍历
1. 依次后根遍历结点的每颗子树
2. 访问根结点
顺序与这颗树对应的二叉树的中序序列相同
### 森林的遍历
#### 先序遍历
1. 访问第一颗树的根结点
2. 先序遍历第一棵树的根结点的子树森林
3. 先序遍历剩余的森林
对应森林的二叉树的先序遍历
#### 中序遍历
1. 中序遍历第一棵树的根结点的子树森林
2. 访问第一颗树的根结点
3. 中序遍历剩余的森林
对应森林的二叉树的中序遍历
# 树和森林的应用
## 哈夫曼树
## 并差集