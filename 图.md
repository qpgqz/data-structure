# 图
## 基本概念
图由点和边构成，即$G=G(V,E)$，其中$V$为顶点集，$E$为边集，$|V|$为顶点的个数，$E$为边的条数。图必须有顶点，可以没有边，不可以是空图。
1. 有向图。其有向边（弧）记为$<v,w>$，表示从v到w的弧，也称v邻接到w。
2. 无向图。其无向边（边）记为$(v,w)$，表示v和w互为邻接点。
3. 简单图。两点之间最多存在一条边，不存在点到自身的边。与之相反的是多重图。
4. 顶点的度。
    - 对于无向图，顶点的度为依附于顶点的边的条数，记为$\text{TD}(v)$。无向图的全部顶点的度之和为边的条数的2倍。
    - 对于有向图，顶点的入度为以顶点为终点的有向边的条数，记为$\text{ID}(v)$，出度为以顶点为起点的有向边的条数，记为$\text{OD}(v)$，顶点的度为入度和出度之和，即$\text{TD}(v)=\text{ID}(v)+\text{OD}(v)$。有向图的全部顶点的入度之和等于出度之和，并且等于有向边之和。
5. 路径与回路。两点之间的路径（walk）为序列$v_0e_1v_1\cdots v_{k-1}e_kv_k$，其中相邻两点$e_{i-1},e_i(i=1,\cdots,k   )$不相同。第一个顶点与最后一个顶点相同的路径构成回路或环。（有向图与无向图的唯一区别就是路径之中的边有没有方向）
   - 若一个图有n个点，大于n-1条边，则一定有环。
   - 简单路径（path）。简单路径是顶点不重复出现的路径。简单回路是除了第一个顶点与最后一个顶点外，其余顶点不重复的回路。
   - 距离。顶点$u,v$之间的距离是从$u$到$v$的最短路径的长度。
6. 子图。若图$G'$的顶点集和边集都包含于图$G$，则称之为子图，如果子图的点集与图相同，则为生成子图。
7. 连通。
   - 无向图中两点之间有路径存在，则连通，任意两点都连通，则无向图连通。连通是无向图点集之间的等价关系，其等价类为连通分量。连通分量可以把图进行完全划分！
   - 有向图中若一对顶点$u,v$从两个方向都有路径，则称之强连通。若任意一对都是强连通，则称有向图强连通。有向图的极大强连通子图成为强连通分量。
   - 有n个顶点的无向图，如果至少有$[\frac{(n-1)(n-2)}{2}]+1$条边，则一定连通。（一个不连通的图的最多边是n-1个点组成完全图，加上一个孤立点）
   - 有向强连通图需要的最小弧数为n。（构成环路）
   - 具有n个顶点的连通图，至少有n-1条边（生成树）
1. 生成树。连通图的生成树是包含图的全部顶点的一个极小连通子图。就是把多余的连通路径删去了，其特点：
   - 只有生成树才是极小连通子图，也就是说必须是树状。
   - 含有n-1条边（具有n个顶点的连通图，至少有n-1条边）
   - 再减少任意一条边都不连通
   - 对于非连通图，其各个连通分量的生成树构成生成森林
   - 对于强连通的有向图也有生成树。一个有向图是强连通的，当且仅当对于中的每一个顶点都存在一个有向树。
2. 边的权。带权的图称为网。（图的应用，比如旅行推销员问题，就可以把权重变成路程的长短）
3.  完全图。完全图也称为简单完全图，
    - 对于无向图，有$\frac{n(n-1)}{2}$条边的无向图为完全图，任意两点之间存在边。
    - 对于有向图，有$n(n-1)$条弧的图为有向完全图，任意两个顶点之间有两条相反方向的弧。
4.  有向树。一个顶点的入度为0，其余顶点的入度为1度有向图称为有向树。
## 存储和操作
### 邻接矩阵
用一位数组存储顶点

用二维数组，即邻接矩阵存储边，即
$$a_{ij}=\begin{cases}
1,&\text{exist }<v_i,v_j> \text{ or }(v_i,v_j)\\
0,&\text{no edge between }v_i \text{ and }v_j
\end{cases}$$

对于网，可令
$$a_{ij}=\begin{cases}
w_{ij},&\text{exist }<v_i,v_j> \text{ or }(v_i,v_j)\\
0\text{ or }\infty,&\text{no edge between }v_i \text{ and }v_j
\end{cases}$$
注意：
1. 邻接矩阵$A^n$的$a_{ij}$意义是从$v_i$到$v_j$的长度为n的路径的数目。
2. 邻接矩阵适用于存储稠密的图
3. 适合查找两点是否相邻
```c
#define MAXVERTEXNUM 100
typedef char vertaxType;
typedef int edgeType;// 可以是只包含0，1的枚举类型
typedef struct{
   vertaxType vex[MAXVERTEXNUM];// 一维数组存点集
   edgeType edge[MAXVERTEXNUM][MAXVERTEXNUM];// 邻接矩阵
   int vexnum, arcnum;// 当前图的顶点和边
}MGrapgh;
```
### 邻接表
邻接表对应的数学概念就是行向量组。对每一个顶点，建立一个单链表，存储所有依附于它（以之为尾）的结点，这个单链表称为顶点的边表（出边表）。边表的头指针和顶点的数据用顺序存储，称为顶点表。
```c
#define MAXVERTEXNUM 100
typedef struct arcNode{
   int adjvex;
   struct arcNode *nextarc;
// infoType info 存储边权值
}arcNode;// 边表结点

typedef struct vNode{
   vertexType data;
   arcNode *firstarc;
}vNode, adjList[MAXVERTEXNUM];// 顶点表

typedef struct{
   adjList vertices;
   int vexnum, arcnum;
}ALGraph;//邻接表
```
特点：
1. 存储空间。对于无向图，存储空间为$|V|+2|E|$，对于有向图，存储空间为$|V|+|E|$
2. 对于稀疏图，可节省很多空间
3. 有向图查某一个结点的入度，需要遍历所有边表
### 十字链表
十字链表是有向图的链式存储结构。它存储了每一个结点以及与之相邻（以之为头或尾）的弧，完全确定一个有向图。

弧结点包括5个域，链式存储：尾域tailtex，首域headtex，首链域hlink，尾链域tlink，信息域info。

顶点结点有3个域，顺序存储：信息域info，头域firstin，尾域firstout。

访问从一个顶点出发的所有弧，可以先访问顶点结点的尾域指向的弧，再依次访问弧的尾链域指向的弧。访问从一个顶点结束的所有弧，可以先访问顶点结点的头域指向的弧，再依次访问弧的头链域指向的弧。

注意⚠️：弧的hink与tlink应该也是按照一个顺序构成一个循环，否则无法遍历。
### 邻接多重表
邻接多重表是无向图的链式存储结构，存储了每一个结点以及

边结点包括5个域：顶点ivex，依附于ivex的下一条边ilink，顶点jvex，依附于jvex的下一条边jlink，信息info。

顶点结点包括两个域：信息域info，依附于该结点的第一条边的指针firstedge。

每一个结点指向一条邻边，这个邻边可以链接出两个链表。与十字链表的不同在于，每一个结点只需要一个链接指向一条邻边即可，即边结点中只要**含有**该结点即可。

邻接表边到边的链接分别由两个部分ivex-ilink，jvex-jlink负责，也就是说要访问一个顶点的所有邻边，从结点1vex到一条边，然后通过这条边中1vex对应的指针找到第二条边，再通过第二条边中1vex对应的指针找到第三条，而不能通过其他结点的指针去找。
### 对比
1. 邻接矩阵和邻接表本质上是储存点以及作为两点连线的边，而十字链表和邻接多重表本质上是存依附于点的所有边。
2. 空间复杂度。
3. 删除点或边的时间复杂度
4. 查找相邻边的时间复杂度
### 基本操作
```c
adjacnet(G, x, y)：判断是否相邻

neighbour(G, x)：列举全部邻边

insertVertex(G, x)

deleteVertex(G, x)

addEdge(G, x, y)

removeEdge(G, x, y)

firstneighbour(G, x)

nextneighbour(G, x, y)：下一个邻接点

getEdgeValue(G, x, y)：获取权值

setEdgeValue(G, x, y)
```
## 图的遍历
### 图论基础
图的遍历是指从一个顶点出发，按照某一种**已经存在的**路径，对所有顶点访问一次，且仅访问一次。其对应的数学概念是哈密顿路径(hamiltonian path)。
### 广度优先搜索
算法思想：从一个点出发，访问和它邻接（距出发点路径长度为1）的所有顶点，再从这些顶点出发，访问没有访问过的邻接结点（距出发点路径长度为2），这样分层访问，直到某一层再也找不到新的顶点。如果还有没有访问的，则从它出发重复上述过程，直到所有点都被访问。

数学思想：一个点出发可以访问包含其的连通分量(本质上是通过最小生成树访问，类似层序遍历)，把所有连通分量都访问就访问了全部的顶点。
#### 算法
```c
// 主算法，以连通分量为单位访问
bool visited[MAXVERTEXNUM];
void BFSTraverse(Graph G){
   for(int i = 0; i < G.vexnum; i++){
      visited[i] = FALSE;// 初始化访问标记数组，防止重复
   initQueue(Q); // 队列里一个连通分量里已经存放访问过，但没有访问其在最小生成树里的子结点的顶点，用于层序遍历
   for(i = 0; i < G.vexnum; i++)
      if(!visited[i])
         BFS(G, i);// 如果第i个结点尚未访问，则遍历第i个结点所在连通分量的全部结点。
   }
} 
```
```c
// 广度优先搜素BFS算法
// 邻接表实现
// 函数功能：按照最小生成树，层序遍历第i个结点的所在的连通分量的全部顶点。
// 只要熟悉层次遍历，就易如反掌
void BFS(ALGraph G, int i){
   // 思考：如果i是连通分量里第一个被访问的，该怎么做？
   // 回答：按照层序遍历访问
   visit(i);// 顶点i是连通分量里第一个访问的
   visited[i] = TRUE;
   enQueue(Q, i);
   while(!isEmpty(Q)){// 层序遍历，把连通分量访问完。
      deQueue(Q, v);
      for(p = G.vertices[v].firstarc; p; p = p->nextarc){// 访问队首结点的所有没有访问过的子顶点，并且让这些子顶点都入队。
         w = p->adjvex;
         if(visited[w] == FALSE){
            visit(w);
            visited[w] = TRUE;
            enQueue(Q, w);
         }
      }
   }
}
```
```c
// BFS算法
// 邻接矩阵实现
// 层序遍历
void BFS(MGraph G, int i){
   visit(i);
   visited[i] = TRUE;
   enQueue(Q,i);
   while(!isEmpty(Q)){
      deQueue(Q,v);
      for(int i = 0; i < G.vexnum; i++)
         if((G.edge[v][i] != 0) && (visited[i] == FALSE)){
            visit(i);
            visited[i] = TRUE;
            enQueue(Q, i);
         }
   }
}
```
#### 特点与应用
1. 时间复杂度。
   - 邻接表方式。需要访问每一个顶点，以及所有的边，所以是|V|+|E|
   - 邻接矩阵方式。需要访问全部的矩阵，因此是|V^2|
2. 空间复杂度。额外占用的空间主要是队列，都是|V|
3. 广度优先生成树。对于邻接矩阵，是唯一的，对于邻接表，是不唯一的。但都是最小生成树。
4. 非带权图的单源最短路径问题（求出所有顶点到一点u的最短距离）。
```c
// 非带权单源最短路径的BFS算法
// BFS遍历 + 赋给每一个结点距离
#define MAXVERTEXNUM 100
#define INFTY MAXVERTEXNUM
void BfsMinDistance(Graph G, int u){
   for(int i = 0; i < G.vexnum; i++)
      visited[i] = FALSE;
      d[i] = INFTY;
   visited[u] = TRUE
   d[u] = 0;
   initQueue(Q);
   enQueue(Q, u);
   while(!isEmpty(Q)){// 只需要访问包含u的连通分量，不连通距离就是∞，不需要访问了。
      deQueue(Q, u);
      for(w = firstneighbour(G, u); w >= 0; w = nextneighbour(G, u, w))
         if(visited[w] == FALSE){
            d[w] = d[u] + 1;// 核心
            visited[w] = TRUE;
            enQueue(Q, w);
         }
   }

}
```
### 深度优先搜索(depth-first-search, DFS)
算法思想：无论是广度优先还是深度优先，本质上都是访问连通分量的最小生成树，但是如果采用广度优先搜索，按访问顺序得到的最小生成树树就像圣诞树🎄那样一层一层的，如果按照深度优先，就是尽可能把树延长，假如图是哈密顿路径，则按访问顺序得到的最小生成树就是一条直线那样的树（就算不是哈密顿环，得到的树也普遍很长，只在最后才分叉）。所以按照不同的遍历方式，对图解构得到的树是完全不一样的。
#### 算法
```c
// 主算法
// DFS深度优先访问包含顶点i的连通分量的所有顶点
void DFSTraverse(Graph G){
   for(int i = 0; i < G.vexnum; i++)
      visited[i] = FALSE;
   for(int i = 0; i < G.vexnum; i++)
      if(visited[i] == FALSE)
         DFS(G, i);
}
```
```c
// DFS算法
// 邻接表实现
// 函数功能：
void DFS(ALGraph G, int i){
      visit(i);
      visited[i] = TRUE;
   for(p = G.vertices[i].firstarc; p; p = p->nextarc){
      int w = p->adjvex;
      if(visited[w] == FALSE){
         DFS(G, w);
      }
   }
}
```
```c
// DFS算法
// 邻接矩阵实现
void DFS(MGraph G, int i){
   visit(i);
   visited[i] = TRUE;
   for(int j = 0; j < G.vexnum; j++)
      if((G.edge[i][j] != 0) && (visited[j] == FALSE))
         DFS(G, j);
}
```
#### 特点
1. 时间复杂度(主要花在寻找下一个结点，而这必须遍历全部可能的邻接点)
   * 邻接表：|E+V|
   * 邻接矩阵：|V^2|
2. 空间复杂度。额外的空间来自递归工作栈，最多为|V|
3. 遍历与连通性
   - 对于无向图，主函数中BFS或DFS调用的次数就是连通分量的个数
   - 对于有向图，未必如此，因为一个连通分量的连通性可能没有达到强连通，需要多次（用十字链表或邻接矩阵仍然可以一次性访问所有结点，但是BFS或DFS的目标是沿着现有的路径去访问，而不能沿着不存在的路径去访问，所以不行！！！）
## 图的应用（非常重要，高频考点）
### 最小生成树

### 最短路径
### 拓扑排序
### 关键路径