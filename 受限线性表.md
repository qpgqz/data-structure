# 受限线性表
主要内容：栈，队列，数组，及其应用。
# 栈
## 栈的抽象特征
### 定义
栈是只允许在一端进行插入和删除的线性表，其特点是后进先出（LIFO）。
### 操作
初始化：```InitStack(&S)```  
判断栈空```StackEmpty(S)```  
入栈：```Push(&S, x)```  
出栈：```Pop(&S, &x)```  
读栈顶元素：```GetTop(S, &x)```  
销毁栈：```DestroyStack(&S)```
## 顺序栈
用连续的存储空间存储栈元素，同时附设一个指针(top)指示当前栈顶元素的位置
### 顺序栈的存储结构
```c
typedef struct{
    //存储和线性表一样，差异在于操作受限，也就是下面定义的函数的功能受限。
    // 若定义top为栈顶的下标，空栈条件为top = -1，栈满条件为 top = maxsize - 1
    // 若定义top为栈顶位序，空栈条件为top = 0，满栈条件为 top = maxsize
    ElemType data[MAXSIZE];
    int top;
}SqStack;
```
### 顺序栈的操作实现
#### 初始化
```c
void InitStack(&S){
    s.top = -1;
}
```
#### 判栈空
```c
bool InitStack(S){
    if(s.top == -1)
        return true;
    else
        return false;
}
```
#### 入栈
```c
bool InitStack(&S, Elemtype e){
    if(S.top == MAXSIZE - 1)
        return false;
    S.data[++S.top] = e;
    retrun true;
}
```
#### 出栈
```c
bool InitStack(&S, &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top--];
    return true;
}
```
#### 读栈顶元素
```c
bool InitStack(S, &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}
```
## 链栈
采用链式存储的栈称为链栈，其优点在于不存在栈满溢的情况。采用单链表存储时，按照规定，只在表头进行插入和删除。链栈的存储与线性表完全一样，只是操作不同。  
主要考察方式是出入栈序列

# 队列
## 队列的抽象特征
### 定义
队列，简称队，也是操作受限的线性表，只允许在表的一端进行插入，而在另一端进行删除。其特点是先进先出(FIFO)。
### 操作
初始化：```InitQueue(&Q)```  
判断队空```QueueEmpty(Q)```  
进队：```EnQueue(&Q, x)```  
出队：```DeQueue(&Q, &x)```  
读队首元素：```GetHead(Q, &x)```  
注意：队列没有访问所有元素的操作
## 队列的顺序存储
用连续的存储空间存储队列元素，同时附设两个指针，队首指针 front 指示队首元素，队尾指针 rear 指向队尾元素的下一个位置。
### 队列的存储结构（只考虑循环队列）
```c
typedef struct{
    // 队首指针的特点：出队则指向下一个元素
    // 队尾指针的特点：入队则指向下一个元素
    ElemType data[MAXSIZE];
    int front, rear;
}SqQueue;
```
### 循环队列的操作
```c
// 初始化
Q.front = Q.rear = 0;
// 出队
x = Q.data[Q.front];
Q.front = (Q.front + 1) % MAXSIZE;
// 入队
Q.data[Q.rear] = x;
Q.rear = (Q.rear + 1) % MAXSIZE;
// 队空条件
Q.rear == Q,front
// 队满条件（牺牲一个存储位置）
(Qs.rear + 1) % MAXSIZE == Q.front
```
## 队列的链式存储
队列的链式存储若采用单链表，则同时拥有首指针和尾指针。
### 链式队列存储结构
```c
typedef struct{
    ElemType data;
    struct LinkNode * next;
}LinkNode;// 结点

typedef struct{
    LinkNode * front, *rear;
}LinkQueue;//队列，用两个指针表示
```
### 不带头节点的链式队列的操作
```c
//初始化
Q.front = Q.rear = NULL;//也是判空条件
//入队
s = (LinkNode *)malloc(sizeof(LinkNode));
s->date = x;
s->next = NULL;
Q.rear->next = s;
Q.rear = s;
//出队（仔细体会）
if(Q.front == Q.rear == NULL)
    return false;
LinkNode *q = Q.front;
x = Q.front->data;
Q.front = Q.front->next;
if(Q.rear == q )//需要单独处理
    Q.rear = NULL;
free(q);
return true;
```
### 带头节点的链式队列的操作（与不带头结点基本没差别）
```c
//初始化
Q.front = Q.rear = (LinkNode *)malloc(sizeof(ElemType))//创立头结点
Q.front->next = NULL;//front永远保持不变
//判空条件
Q.rear == Q.front;
//入队与不带头结点相同
//出队
if(Q.front == Q.rear)
    return false;
LinkNode *q = Q.front->next;
x = q->data;
Q.front->next = q->next;
if(Q.rear == q )//需要单独处理
    Q.rear = Q.front;
free(q);
retrun true;
```
## 双端队列
双端队列是两边都可以进行插入和删除队线性表，也就是说，既包括了栈，也包括了队列，还可以是两者的混合。用队列这个词其实有点误导性。  
双端队列主要考察出入序列的合法性
# 栈和队列的应用
## 栈与括号匹配
括号匹配的原则：左括号入栈，右括号必须与栈顶的左括号匹配，结束时必须栈空。
## 栈与表达式求值
中缀表达式：用括号明示优先级，然后从最内层的括号开始依次计算。  
后缀表达式：没有括号，优先级用运算符的左右顺序表达，左边的优先级大。其特点是只要遇到了运算符，就可以直接计算，因为已经按照运算的优先程度排好序了。注意，运算本质上只能一个一个地算。 
### 中缀转后缀
#### 手算方法 
1 将所有运算加括号  
2 在每一个括号内将运算法放到最后  
3 去掉所有括号  
#### 算法（逆波兰算法，由 Edsger Dijkstra 提出）：
用栈来存储还不能直接计算的操作符  
- 遇到操作数，直接加入输出队列  
- 遇到括号
  1. 若是"(“，则压栈
  2. 若失")"，将栈中运算符依次取出，直到遇到"("，弹出之，不加入输出队列
- 遇到操作符，比较它和栈顶操作符的优先级
  1. 若是右结合算符"^"，直接压栈
  2. 若是其他算符：
   * 若操作符优先级高于栈顶操作符，或着空栈，或着栈顶为"(",则压栈
   *  若优先级小于等于栈顶运算符，将栈中的运算符中优先级大于等于它的都依次弹出（左括号"("不弹出），加入输入队列中。

- 扫描结束后，将所有运算符弹出，加入输出队列
### 后缀表达式求值

## 栈与递归
## 队列与层次遍历
# 数组和特殊矩阵