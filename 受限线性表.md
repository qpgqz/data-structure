# 受限线性表
主要内容：栈，队列，数组，及其应用。  
主要考选择题  
栈和队列的算法题只需要用伪代码表示栈和队列的运算即可，不需要可运行。
# 栈
## 栈的抽象特征
### 定义
栈是只允许在一端进行插入和删除的线性表，其特点是后进先出（LIFO）。
### 操作
初始化：```InitStack(&S)```  
判断栈空```StackEmpty(S)```  
入栈：```Push(&S, x)```  
出栈：```Pop(&S, &x)```  
读栈顶元素：```GetTop(S, &x)```  
销毁栈：```DestroyStack(&S)```
## 顺序栈
用连续的存储空间存储栈元素，同时附设一个指针(top)指示当前栈顶元素的位置
### 顺序栈的存储结构
```c
typedef struct{
    //存储和线性表一样，差异在于操作受限，也就是下面定义的函数的功能受限。
    // 若定义top为栈顶的下标，空栈条件为top = -1，栈满条件为 top = maxsize - 1
    // 若定义top为栈顶位序，空栈条件为top = 0，满栈条件为 top = maxsize
    ElemType data[MAXSIZE];
    int top;
}SqStack;
```
### 顺序栈的操作实现
#### 初始化
```c
void InitStack(&S){
    s.top = -1;
}
```
#### 判栈空
```c
bool InitStack(S){
    if(s.top == -1)
        return true;
    else
        return false;
}
```
#### 入栈
```c
bool InitStack(&S, Elemtype e){
    if(S.top == MAXSIZE - 1)
        return false;
    S.data[++S.top] = e;
    retrun true;
}
```
#### 出栈
```c
bool InitStack(&S, &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top--];
    return true;
}
```
#### 读栈顶元素
```c
bool InitStack(S, &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}
```
## 链栈
采用链式存储的栈称为链栈，其优点在于不存在栈满溢的情况。采用单链表存储时，按照规定，只在表头进行插入和删除。链栈的存储与线性表完全一样，只是操作不同。  
主要考察方式是出入栈序列

# 队列
## 队列的抽象特征
### 定义
队列，简称队，也是操作受限的线性表，只允许在表的一端进行插入，而在另一端进行删除。其特点是先进先出(FIFO)。
### 操作
初始化：```InitQueue(&Q)```  
判断队空```QueueEmpty(Q)```  
进队：```EnQueue(&Q, x)```  
出队：```DeQueue(&Q, &x)```  
读队首元素：```GetHead(Q, &x)```  
注意：队列没有访问所有元素的操作
## 队列的顺序存储
用连续的存储空间存储队列元素，同时附设两个指针，队首指针 front 指示队首元素，队尾指针 rear 指向队尾元素的下一个位置。
### 队列的存储结构（只考虑循环队列）
```c
typedef struct{
    // 队首指针的特点：出队则指向下一个元素
    // 队尾指针的特点：入队则指向下一个元素
    ElemType data[MAXSIZE];
    int front, rear;
}SqQueue;
```
### 循环队列的操作
```c
// 初始化
Q.front = Q.rear = 0;
// 出队
x = Q.data[Q.front];
Q.front = (Q.front + 1) % MAXSIZE;
// 入队
Q.data[Q.rear] = x;
Q.rear = (Q.rear + 1) % MAXSIZE;
// 队空条件
Q.rear == Q,front
// 队满条件（牺牲一个存储位置）
(Qs.rear + 1) % MAXSIZE == Q.front
```
## 队列的链式存储
队列的链式存储若采用单链表，则同时拥有首指针和尾指针。
### 链式队列存储结构
```c
typedef struct{
    ElemType data;
    struct LinkNode * next;
}LinkNode;// 结点

typedef struct{
    LinkNode * front, *rear;
}LinkQueue;//队列，用两个指针表示
```
### 不带头节点的链式队列的操作
```c
//初始化
Q.front = Q.rear = NULL;//也是判空条件
//入队
s = (LinkNode *)malloc(sizeof(LinkNode));
s->date = x;
s->next = NULL;
Q.rear->next = s;
Q.rear = s;
//出队（仔细体会）
if(Q.front == Q.rear == NULL)
    return false;
LinkNode *q = Q.front;
x = Q.front->data;
Q.front = Q.front->next;
if(Q.rear == q )//需要单独处理
    Q.rear = NULL;
free(q);
return true;
```
### 带头节点的链式队列的操作（与不带头结点基本没差别）
```c
//初始化
Q.front = Q.rear = (LinkNode *)malloc(sizeof(ElemType))//创立头结点
Q.front->next = NULL;//front永远保持不变
//判空条件
Q.rear == Q.front;
//入队与不带头结点相同
//出队
if(Q.front == Q.rear)
    return false;
LinkNode *q = Q.front->next;
x = q->data;
Q.front->next = q->next;
if(Q.rear == q )//需要单独处理
    Q.rear = Q.front;
free(q);
retrun true;
```
## 双端队列
双端队列是两边都可以进行插入和删除队线性表，也就是说，既包括了栈，也包括了队列，还可以是两者的混合。用队列这个词其实有点误导性。  
双端队列主要考察出入序列的合法性
# 栈和队列的应用
## 栈与括号匹配
括号匹配的原则：左括号入栈，右括号必须与栈顶的左括号匹配，结束时必须栈空。
## 栈与表达式求值
中缀表达式：用括号明示优先级，然后从最内层的括号开始依次计算。  
后缀表达式：没有括号，优先级用运算符的左右顺序表达，左边的优先级大。其特点是只要遇到了运算符，就可以直接计算，因为已经按照运算的优先程度排好序了。注意，运算本质上只能一个一个地算。 
### 中缀转后缀
#### 手算方法 
1 将所有运算加括号  
2 在每一个括号内将运算法放到最后  
3 去掉所有括号  
#### 算法（逆波兰算法，由 Edsger Dijkstra 提出）：
用栈来存储还不能直接计算的操作符  
- 遇到操作数，直接加入输出队列  
- 遇到括号
  1. 若是"(“，则压栈
  2. 若失")"，将栈中运算符依次取出，直到遇到"("，弹出之，不加入输出队列
- 遇到操作符，比较它和栈顶操作符的优先级
  1. 若是右结合算符"^"，直接压栈
  2. 若是其他算符：
   * 若操作符优先级高于栈顶操作符，或着空栈，或着栈顶为"(",则压栈
   *  若优先级小于等于栈顶运算符，将栈中的运算符中优先级大于等于它的都依次弹出（左括号"("不弹出），加入输入队列中。

- 扫描结束后，将所有运算符弹出，加入输出队列
### 后缀表达式求值
从左往右依次扫描后缀表达式，若是操作数，则压栈，若是操作符，就取出两个操作数，进行计算，将结果压栈。当扫描结束，栈中就是结果。
## 栈与递归
递归函数：若函数在定义中又用到了自身，则为递归函数。其代码简洁，但效率不高。  
例子：佩波那契数列的递归计算，阶乘，数学归纳法的证明？  
递归工作栈：每一层递归都必须存储局部变量，传入实参，以及返回地址，这些信息都存在递归工作栈中，每次递归就开辟一个新栈帧存储该递归的信息，每次递归调用结束就弹出栈顶，到上一层。这比其他的存储结构都更合适。

## 队列与二叉树层次遍历
比如有一个二叉树，代表一个家族的传承。现在需要把人的名字按照辈分依次打印出来，算法如下：  
1. 根结点（祖宗）入队
2. 若队空，则结束遍历，否则重复3
3. 队首出队，若其有左孩子（长子），则入队，有右孩子（次子）也入队
# 数组和特殊矩阵
### 定义
数组是维度和维界固定的线性表，一旦定义，就只能读取和修改元素。  
其对应的物理量为张量。一位数组对应向量，二位数组对应矩阵（2阶张量），三维数组对应3阶张量（魔方）。  
## 一般存储
以二维数组为例，有行优先和列优先两种存储方法。  
1. 行优先：$\text{LOC}(a_{ij})=\text{LOC}(a_{00})+[i\times(h_2)+j]\times L$
2. 列优先：$\text{LOC}(a_{ij})=\text{LOC}(a_{00})+[j\times(h_1)+i]\times L$
## 特殊矩阵的压缩存储
压缩存储：为多个值相同的元素只分配一个存储空间，对0元素不分配空间。关键在于找出规律性。
### 对称矩阵
只需要存储下三角部分与对角部分。设存储于一维数组B之中，则$a_{ij} \to b[k]$的映射关系是
$$
k=
\begin{cases}
1+\cdots+(i-1)+j-1，&j\le i\\
1+\cdots+(j-1)+i-1,&j>i
\end{cases}
$$
即先存储下三角，而上三角的存储区域与其转置一致。
### 下三角矩阵
只需要存储下三角以及常量
$$
k=
\begin{cases}
1+\cdots+(i-1)+j-1，&j\le i\\
\frac{n(n+1)}{2}, &j>i
\end{cases}
$$
### 上三角矩阵
只需要存储上三角以及常量
$$
k=
\begin{cases}
n+\cdots+(n-i+2)+j-i，&j\ge i\\
\frac{n(n+1)}{2}, &j<i
\end{cases}
$$
### 三对角矩阵
映射：先考虑$a_{ii}$的存储，再考虑$a_{ij}$
$$
k=i+2(i-1)+j-i-1=2i+j-3，|i-j|<=1
$$
若根据 k 求$a_{ij}$，先求$i=[\frac{k+1}{3}]+1$，再根据公式得$j=k+3-2i$。
### 稀疏矩阵
稀疏矩阵就是0很多，非零很少的矩阵。这时与其全部存储，不如只存储非零元素的位置和值，以及矩阵的行，列，零元素的个数等少量信息。
```c
//用三元组来存储
#define MAXSIZE 100 // 假设最多能存储100个非零元

typedef struct {
    int row;    // 行下标
    int col;    // 列下标
    int value;  // 元素值 (根据矩阵类型，也可以是float, double等)
} Triple;

typedef struct {
    Triple data[MAXSIZE + 1]; // 存储三元组的数组，data[0]未使用或用于存储矩阵信息
    int rows, cols, nums;     // 矩阵的总行数、总列数、非零元素个数
} TSMatrix;
```
